# leetcode problems 0051-0100

51. [N-Queens](https://leetcode.com/problems/n-queens/)

```js
function solveNQueens(n: number): string[][] {
  let res = [];
  if (n === 1 || n >= 4) dfs(res, [], n, 0);
  return res;
}

function dfs(res, points, n, index) {
  for (let i = index; i < n; i++) {
    if (points.length !== i) return;
    for (let j = 0; j < n; j++) {
      if (isValid(points, [i, j])) {
        points.push([i, j]);
        dfs(res, points, n, i + 1);
        if (points.length === n) res.push(buildRes(points));
        points.pop();
      }
    }
  }
}

function buildRes(points) {
  let res = [];
  let n = points.length;
  for (let i = 0; i < n; i++) {
    res[i] = "";
    for (let j = 0; j < n; j++) {
      res[i] += points[i][1] === j ? "Q" : ".";
    }
  }
  return res;
}

function isValid(oldPoints, newPoint) {
  let len = oldPoints.length;
  for (let i = 0; i < len; i++) {
    if (oldPoints[i][0] === newPoint[0] || oldPoints[i][1] === newPoint[1])
      return false;
    if (
      Math.abs(
        (oldPoints[i][0] - newPoint[0]) / (oldPoints[i][1] - newPoint[1])
      ) === 1
    )
      return false;
  }
  return true;
}
```

52. [N-Queens II](https://leetcode.com/problems/n-queens-ii/)

```js
function totalNQueens(n: number): number {
  if (n === 1 || n >= 4) return dfs([], n, 0);
  return 0;
}

function dfs(points, n, index) {
  let res = 0;
  if (points.length === n) return 1;
  for (let i = index; i < n; i++) {
    if (points.length !== i) return res;
    for (let j = 0; j < n; j++) {
      if (!isValid(points, [i, j])) continue;
      points.push([i, j]);
      res += dfs(points, n, i + 1);
      points.pop();
    }
  }
  return res;
}

function isValid(oldPoints, newPoint) {
  let len = oldPoints.length;
  for (let i = 0; i < len; i++) {
    if (oldPoints[i][0] === newPoint[0] || oldPoints[i][1] === newPoint[1])
      return false;
    if (
      Math.abs(
        (oldPoints[i][0] - newPoint[0]) / (oldPoints[i][1] - newPoint[1])
      ) === 1
    )
      return false;
  }
  return true;
}
```

53. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

```js
function maxSubArray(nums: number[]): number {
  let len = nums.length;
  let max = Number.MIN_SAFE_INTEGER;
  let prev = 0;
  let curr = 0;

  if (!len) return 0;

  for (let i = 0; i < len; i++) {
    curr = Math.max(prev + nums[i], nums[i]);
    max = Math.max(curr, max);
    prev = curr;
  }

  return max;
}
```

54. [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

```js
function spiralOrder(matrix: number[][]): number[] {
  let n = matrix.length;
  let m = (matrix[0] || []).length;
  let res = [];
  let x1 = 0;
  let x2 = m - 1;
  let y1 = 0;
  let y2 = n - 1;
  while (x1 <= x2 && y1 <= y2) {
    for (let x = x1; x <= x2; x++) res.push(matrix[y1][x]);
    for (let y = y1 + 1; y <= y2; y++) res.push(matrix[y][x2]);
    if (x1 < x2 && y1 < y2) {
      for (let x = x2 - 1; x > x1; x--) res.push(matrix[y2][x]);
      for (let y = y2; y > y1; y--) res.push(matrix[y][x1]);
    }
    x1++;
    x2--;
    y1++;
    y2--;
  }
  return res;
}
```

55. [Jump Game](https://leetcode.com/problems/jump-game/)

```js
function canJump(nums: number[]): boolean {
  let len = nums.length;
  let max = 0;
  for (let i = 0; i < len; i++) {
    if (i > max) return false;
    max = Math.max(max, i + nums[i]);
  }
  return true;
}
```

56. [Merge Intervals](https://leetcode.com/problems/merge-intervals/)

```js
function Interval(start, end) {
  this.start = start;
  this.end = end;
}

function merge(intervals: number[][]): number[][] {
  let result = [];
  let myIntervals = [];
  for (const interval of intervals) {
    myIntervals.push(new Interval(interval[0], interval[1]));
  }
  let len = myIntervals.length;
  let res = [];
  let a = null;
  let b = null;

  myIntervals.sort((c, d) => c.start - d.start);

  for (let i = 0; i < len; i++) {
    a = res[res.length - 1];
    b = myIntervals[i];

    if (overlap(a, b)) {
      a.start = Math.min(a.start, b.start);
      a.end = Math.max(a.end, b.end);
    } else {
      res.push(new Interval(b.start, b.end));
    }
  }

  for (const interval of res) {
    result.push([interval.start, interval.end]);
  }
  return result;
}

function overlap(a, b) {
  if (!a || !b) return false;
  if (b.start <= a.end && a.end <= b.end) return true;
  if (a.start <= b.end && b.end <= a.end) return true;
  return false;
}
```

57. [Insert Interval](https://leetcode.com/problems/insert-interval/)

```js
function Interval(start, end) {
  this.start = start;
  this.end = end;
}

function insert(intervals: number[][], newInterval: number[]): number[][] {
  let result = [];
  let myIntervals = [];
  let myNewInterval = new Interval(newInterval[0], newInterval[1]);
  for (const interval of intervals) {
    myIntervals.push(new Interval(interval[0], interval[1]));
  }
  let len = myIntervals.length;
  let i = 0;
  let res = [];
  while (i < len && myIntervals[i].end < myNewInterval.start) {
    res.push(myIntervals[i]);
    i++;
  }
  while (i < len && myIntervals[i].start <= myNewInterval.end) {
    myNewInterval.start = Math.min(myNewInterval.start, myIntervals[i].start);
    myNewInterval.end = Math.max(myNewInterval.end, myIntervals[i].end);
    i++;
  }
  res.push(myNewInterval);
  while (i < len) {
    res.push(myIntervals[i]);
    i++;
  }
  for (const interval of res) {
    result.push([interval.start, interval.end]);
  }
  return result;
}
```

58. [Length of Last Word](https://leetcode.com/problems/length-of-last-word/)

```js
function lengthOfLastWord(s: string): number {
  s = s.trim();
  let len = s.length;
  let i = len - 1;
  while (i >= 0 && s[i] !== " ") i--;
  return len - 1 - i;
}
```

59. [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)

```js
function generateMatrix(n: number): number[][] {
  let x1 = 0;
  let x2 = n - 1;
  let y1 = 0;
  let y2 = n - 1;
  let i = 0;
  let res = Array(n)
    .fill(0)
    .map((_) => Array(n));
  while (x1 <= x2 && y1 <= y2) {
    for (let x = x1; x <= x2; x++) res[y1][x] = ++i;
    for (let y = y1 + 1; y <= y2; y++) res[y][x2] = ++i;
    for (let x = x2 - 1; x > x1; x--) res[y2][x] = ++i;
    for (let y = y2; y > y1; y--) res[y][x1] = ++i;
    x1++;
    x2--;
    y1++;
    y2--;
  }
  return res;
}
```

60. [Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)

```js
function getPermutation(n: number, k: number): string {
  let str = "";
  let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  let factorial = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]; // n!
  let tmp1 = 0;
  let tmp2 = 0;

  k--;

  for (let j = n; j >= 1; j--) {
    tmp1 = factorial[j - 1];
    tmp2 = Math.floor(k / tmp1);

    k %= tmp1;
    str += nums[tmp2];

    nums.splice(tmp2, 1);
  }

  return str;
}
```

61. [Rotate List](https://leetcode.com/problems/rotate-list/)

```js
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function rotateRight(head: ListNode | null, k: number): ListNode | null {
  let count = 1;
  let last = head;
  let curr = head;

  if (!head || !head.next) return head;

  while (last.next) {
    last = last.next;
    count++;
  }

  k %= count;

  if (k === 0) return head;

  while (k < count - 1) {
    curr = curr.next;
    k++;
  }

  last.next = head;
  head = curr.next;
  curr.next = null;

  return head;
}
```

62. [Unique Paths](https://leetcode.com/problems/unique-paths/)

```js
function uniquePaths(m: number, n: number): number {
  let dp = Array(m);
  if (!m || !n) return 0;
  for (var i = 0; i < m; i++) {
    dp[i] = Array(n);
    for (var j = 0; j < n; j++) {
      if (j > 0 && i > 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
      else if (j > 0 && i === 0) dp[i][j] = dp[i][j - 1];
      else if (j === 0 && i > 0) dp[i][j] = dp[i - 1][j];
      else dp[i][j] = 1;
    }
  }
  return dp[m - 1][n - 1];
}
```

63. [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

```js
function uniquePathsWithObstacles(obstacleGrid: number[][]): number {
  let m = obstacleGrid.length;
  let n = (obstacleGrid[0] || []).length;
  let dp = Array(m);
  let left = 0;
  let top = 0;

  if (!m || !n) return 0;

  for (let i = 0; i < m; i++) {
    dp[i] = Array(n);
    for (let j = 0; j < n; j++) {
      left = j === 0 || obstacleGrid[i][j - 1] === 1 ? 0 : dp[i][j - 1];
      top = i === 0 || obstacleGrid[i - 1][j] === 1 ? 0 : dp[i - 1][j];
      dp[i][j] =
        obstacleGrid[i][j] === 1 ? 0 : i === 0 && j === 0 ? 1 : left + top;
    }
  }

  return dp[m - 1][n - 1];
}
```

64. [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

```js
function minPathSum(grid: number[][]): number {
  let m = grid.length;
  let n = (grid[0] || []).length;
  let dp = Array(m);
  let left = 0;
  let top = 0;

  if (!m || !n) return 0;

  for (let i = 0; i < m; i++) {
    dp[i] = Array(n);
    for (let j = 0; j < n; j++) {
      top = i === 0 ? Number.MAX_SAFE_INTEGER : dp[i - 1][j];
      left = j === 0 ? Number.MAX_SAFE_INTEGER : dp[i][j - 1];
      dp[i][j] = grid[i][j] + (i === 0 && j === 0 ? 0 : Math.min(left, top));
    }
  }

  return dp[m - 1][n - 1];
}
```

65. [Valid Number](https://leetcode.com/problems/valid-number/)

```js
function isNumber(s: string): boolean {
  // cheap shot
  //return !isNaN(Number(s));
  let state = [
    {},
    { blank: 1, sign: 2, digit: 3, ".": 4 },
    { digit: 3, ".": 4 },
    { digit: 3, ".": 5, e: 6, E: 6, blank: 9 },
    { digit: 5 },
    { digit: 5, e: 6, E: 6, blank: 9 },
    { sign: 7, digit: 8 },
    { digit: 8 },
    { digit: 8, blank: 9 },
    { blank: 9 }
  ];
  let validState = [3, 5, 8, 9];
  let currentState = 1;
  let len = s.length;
  let str = "";
  let type = "";
  for (let i = 0; i < len; i++) {
    str = s[i];
    if (str >= "0" && str <= "9") {
      type = "digit";
    } else if (str === "+" || str === "-") {
      type = "sign";
    } else if (str === " ") {
      type = "blank";
    } else {
      type = str;
    }
    if (state[currentState][type] === undefined) {
      return false;
    } else {
      currentState = state[currentState][type];
    }
  }
  if (validState.indexOf(currentState) === -1) {
    return false;
  } else {
    return true;
  }
}
```

66. [Plus One](https://leetcode.com/problems/plus-one/)

```js
function plusOne(digits: number[]): number[] {
  let i = digits.length - 1;
  let val = 0;
  let carry = 1;
  while (i >= 0 && carry) {
    val = digits[i] + carry;
    carry = Math.floor(val / 10);
    digits[i] = val % 10;
    i--;
  }
  if (carry) digits.unshift(carry);
  return digits;
}
```

67. [Add Binary](https://leetcode.com/problems/add-binary/)

```js
function addBinary(a: string, b: string): string {
  let len1 = a.length;
  let len2 = b.length;
  let maxLength = Math.max(len1, len2);
  let res = "";
  let carry = 0;
  let val = 0;

  for (let i = 0; i < maxLength; i++) {
    val = Number(a[len1 - 1 - i] || 0) + Number(b[len2 - 1 - i] || 0) + carry;
    carry = Math.floor(val / 2);
    res = (val % 2) + res;
  }

  if (carry) res = 1 + res;

  return res;
}
```

68. [Text Justification]()

```js
function fullJustify(words: string[], maxWidth: number): string[] {
  let len = words.length;
  let arr = [];
  let width = 0;
  let item = null;
  let addLen = 0;
  let res = [];

  for (let i = 0; i < len; i++) {
    item = words[i];
    addLen = width === 0 ? item.length : item.length + 1;

    if (width + addLen > maxWidth) {
      res.push(helper(arr, maxWidth - width, false));
      arr = [];
      width = 0;
      addLen = item.length;
    }

    arr.push(item);
    width += addLen;
  }

  res.push(helper(arr, maxWidth - width, true));

  return res;
}

function helper(arr, left, isLast) {
  let len = arr.length;
  let num = 0;
  let rem = 0;
  let res = "";

  if (len === 1 || isLast) {
    return arr.join(" ") + " ".repeat(left);
  }

  num = Math.floor(left / (len - 1));
  rem = left % (len - 1);
  for (let i = 0; i < len; i++) {
    res += arr[i];
    if (i < len - 1) res += " ".repeat(num + 1);
    if (i < rem) res += " ";
  }

  return res;
}
```

69. [Sqrt(x)](https://leetcode.com/problems/sqrtx/)

```js
function mySqrt(x: number): number {
  if (x < 2) return x;
  let left = 1;
  let right = x;
  let mid = 0;
  while (left <= right) {
    mid = left + Math.floor((right - left) / 2);
    if (mid > x / mid) {
      right = mid - 1;
    } else if (mid + 1 > x / (mid + 1)) {
      return mid;
    } else {
      left = mid + 1;
    }
  }
}
```

70. [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

```js
function climbStairs(n: number): number {
  let dp = [0, 1];
  for (let i = 0; i < n; i++) {
    dp = [dp[1], dp[0] + dp[1]];
  }
  return dp[1];
}
```

71. [Simplify Path](https://leetcode.com/problems/simplify-path/)

```js
function simplifyPath(path: string): string {
  let arr = path.split("/");
  let stack = [];
  let len = arr.length;
  let item = "";
  for (let i = 0; i < len; i++) {
    item = arr[i];
    if (item === "" || item === ".") continue;
    if (item === "..") {
      stack.pop();
    } else {
      stack.push(item);
    }
  }
  return "/" + stack.join("/");
}
```

72. [Edit Distance](https://leetcode.com/problems/edit-distance/)

```js
function minDistance(word1: string, word2: string): number {
  let n = word1.length;
  let m = word2.length;
  let dp = Array(n);

  for (let i = 0; i < n; i++) {
    dp[i] = Array(m);
    for (let j = 0; j < m; j++) {
      dp[i][j] = Math.min(
        getDp(i - 1, j, dp) + 1,
        getDp(i, j - 1, dp) + 1,
        getDp(i - 1, j - 1, dp) + (word1[i] === word2[j] ? 0 : 1)
      );
    }
  }

  return getDp(n - 1, m - 1, dp);
}

function getDp(i, j, dp) {
  if (i < 0 && j < 0) return 0;
  if (i < 0) return j + 1;
  if (j < 0) return i + 1;
  return dp[i][j];
}
```

73. [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

```js
function setZeroes(matrix: number[][]): void {
  let m = matrix.length;
  let n = (matrix[0] || []).length;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (matrix[i][j] === 0) {
        left(i, j, m, n, matrix);
        right(i, j, m, n, matrix);
        up(i, j, m, n, matrix);
        down(i, j, m, n, matrix);
      } else if (matrix[i][j] === Number.MIN_SAFE_INTEGER) {
        matrix[i][j] = 0;
      }
    }
  }
}

function left(i, j, m, n, matrix) {
  for (let k = j - 1; k >= 0; k--) {
    matrix[i][k] = 0;
  }
}

function right(i, j, m, n, matrix) {
  for (let k = j + 1; k < n; k++) {
    matrix[i][k] = matrix[i][k] === 0 ? 0 : Number.MIN_SAFE_INTEGER;
  }
}

function up(i, j, m, n, matrix) {
  for (let k = i - 1; k >= 0; k--) {
    matrix[k][j] = 0;
  }
}

function down(i, j, m, n, matrix) {
  for (let k = i + 1; k < m; k++) {
    matrix[k][j] = matrix[k][j] === 0 ? 0 : Number.MIN_SAFE_INTEGER;
  }
}
```

74. [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)

flattern the 2d array to 1d array, binary search the 1d array.

Or do binary search on row and column.

```js
function searchMatrix(matrix: number[][], target: number): boolean {
  let row = searchRow(matrix, target, 0, matrix.length - 1);
  return row === -1
    ? false
    : searchArray(matrix[row], target, 0, matrix[row].length - 1);
}

function searchRow(matrix, target, top, bottom) {
  if (top > bottom) return -1;
  let mid = top + Math.floor((bottom - top) / 2);
  let len = matrix[mid].length;
  if (len === 0) return -1;
  if (matrix[mid][0] <= target && target <= matrix[mid][len - 1]) {
    return mid;
  } else if (target < matrix[mid][0]) {
    return searchRow(matrix, target, top, mid - 1);
  } else {
    return searchRow(matrix, target, mid + 1, bottom);
  }
}

function searchArray(arr, target, left, right) {
  if (left > right) return false;
  let mid = left + Math.floor((right - left) / 2);
  if (arr[mid] === target) {
    return true;
  } else if (arr[mid] > target) {
    return searchArray(arr, target, left, mid - 1);
  } else {
    return searchArray(arr, target, mid + 1, right);
  }
}
```

75. [Sort Colors](https://leetcode.com/problems/sort-colors/)

```js
function sortColors(nums: number[]): void {
  let j = 0;
  let k = nums.length - 1;
  for (let i = 0; i <= k; i++) {
    if (nums[i] === 0) {
      swap(nums, i, j++);
    } else if (nums[i] === 2) {
      swap(nums, i--, k--);
    }
  }
}

function swap(arr, a, b) {
  let tmp = arr[a];
  arr[a] = arr[b];
  arr[b] = tmp;
}
```

76. [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

```js
function minWindow(s: string, t: string): string {
  let map = {};
  let sLen = s.length;
  let tLen = t.length;
  let count = tLen;
  let min = Number.MAX_SAFE_INTEGER;
  let head = 0;
  let left = 0;
  let right = 0;

  if (!sLen || !tLen) return "";

  for (let i = 0; i < tLen; i++) {
    if (map[t[i]] === undefined) {
      map[t[i]] = 1;
    } else {
      map[t[i]]++;
    }
  }

  while (right < sLen) {
    if (map[s[right]] !== undefined) {
      if (map[s[right]] > 0) count--;
      map[s[right]]--;
    }

    right++;

    while (count === 0) {
      if (right - left < min) {
        min = right - left;
        head = left;
      }

      if (map[s[left]] !== undefined) {
        if (map[s[left]] === 0) count++;
        map[s[left]]++;
      }

      left++;
    }
  }

  return min === Number.MAX_SAFE_INTEGER ? "" : s.substr(head, min);
}
```
