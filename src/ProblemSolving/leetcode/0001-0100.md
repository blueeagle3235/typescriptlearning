# leetcode problems 0001-0100

<https://leetcode.com/problemset/all/?page=1> and select 100 / page

1. [two sum](https://leetcode.com/problems/two-sum/) - Easy

two for loops, i & j, j starts from i + 1, if num[i]+num[j]===target return [i,j]

2. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) - Medium

<https://redquark.org/leetcode/0002-add-two-numbers/>

```js
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(
  l1: ListNode | null,
  l2: ListNode | null
): ListNode | null {
  // Head of the new linked list - this is the head of the resultant list
  let head = null;
  // Reference of head which is null at this point
  let curr = null;
  // Carry
  let carry = 0;
  // Loop for the two lists
  while (l1 !== null || l2 !== null) {
    // At the start of each iteration, we should add carry from the last iteration
    let sum = carry;
    // Since the lengths of the lists may be unequal, we are checking if the
    // current node is null for one of the lists
    if (l1 != null) {
      sum += l1.val;
      l1 = l1.next;
    }
    if (l2 != null) {
      sum += l2.val;
      l2 = l2.next;
    }
    // At this point, we will add the total sum % 10 to the new node
    // in the resultant list
    let node = new ListNode(Math.floor(sum) % 10);
    // Carry to be added in the next iteration
    carry = Math.floor(sum / 10);
    // If this is the first node or head
    if (curr == null) {
      head = node;
      curr = head;
    }
    // For any other node
    else {
      curr.next = node;
      curr = curr.next;
    }
  }
  // After the last iteration, we will check if there is carry left
  // If it's left then we will create a new node and add it
  if (carry > 0) {
    curr.next = new ListNode(carry);
  }
  return head;
}
```

3. [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) - Medium

the key is to understand and utilize [sliding window algorithm](https://redquark.org/cotd/sliding_window/)

<https://redquark.org/leetcode/0003-longest-substring-without-repeating-characters/>

```js
function lengthOfLongestSubstring(s: string): number {
  if (!s) {
    return 0;
  }
  // Starting index of the window
  let start = 0;
  // Ending index of the window
  let end = 0;
  // Maximum length of the substring
  let maxLength = 0;
  // Set to store the unique characters
  const uniqueCharacters = new Set();
  // Loop for each character in the string
  while (end < s.length) {
    if (!uniqueCharacters.has(s[end])) {
      uniqueCharacters.add(s[end]);
      end++;
      maxLength = Math.max(maxLength, uniqueCharacters.size);
    } else {
      uniqueCharacters.delete(s[start]);
      start++;
    }
  }
  return maxLength;
}
```

4. [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) - Hard

<https://redquark.org/leetcode/0004-median-of-two-sorted-arrays/>

```js
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  // Check if num1 is smaller than num2
  // If not, then we will swap num1 with num2
  if (nums1.length > nums2.length) {
    return findMedianSortedArrays(nums2, nums1);
  }
  // Lengths of two arrays
  const m = nums1.length;
  const n = nums2.length;
  // Pointers for binary search
  let start = 0;
  let end = m;
  // Binary search starts from here
  while (start <= end) {
    // Partitions of both the array
    let partitionNums1 = Math.floor((start + end) / 2);
    let partitionNums2 = Math.floor((m + n + 1) / 2) - partitionNums1;
    // Edge cases
    // If there are no elements left on the left side after partition
    let maxLeftNums1 =
      partitionNums1 == 0 ? Number.MIN_SAFE_INTEGER : nums1[partitionNums1 - 1];
    // If there are no elements left on the right side after partition
    let minRightNums1 =
      partitionNums1 == m ? Number.MAX_SAFE_INTEGER : nums1[partitionNums1];
    // Similarly for nums2
    let maxLeftNums2 =
      partitionNums2 == 0 ? Number.MIN_SAFE_INTEGER : nums2[partitionNums2 - 1];
    let minRightNums2 =
      partitionNums2 == n ? Number.MAX_SAFE_INTEGER : nums2[partitionNums2];
    // Check if we have found the match
    if (maxLeftNums1 <= minRightNums2 && maxLeftNums2 <= minRightNums1) {
      // Check if the combined array is of even/odd length
      if ((m + n) % 2 == 0) {
        let num =
          (Math.max(maxLeftNums1, maxLeftNums2) +
            Math.min(minRightNums1, minRightNums2)) /
          2.0;
        return num;
      } else {
        return Math.max(maxLeftNums1, maxLeftNums2);
      }
    }
    // If we are too far on the right, we need to go to left side
    else if (maxLeftNums1 > minRightNums2) {
      end = partitionNums1 - 1;
    }
    // If we are too far on the left, we need to go to right side
    else {
      start = partitionNums1 + 1;
    }
  }
}
```

5. [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) - Medium

<https://redquark.org/leetcode/0005-longest-palindromic-substring/>

```js
function longestPalindrome(s: string): string {
  // Update the string to put hash "#" at the beginning, end and in between each character
  let updatedString = getUpdatedString(s);
  // Length of the array that will store the window of palindromic substring
  const length = 2 * s.length + 1;
  // Array to store the length of each palindrome centered at each element
  let p = Array(length);
  p.fill(0);
  // Current center of the longest palindromic string
  let c = 0;
  // Right boundary of the longest palindromic string
  let r = 0;
  // Maximum length of the substring
  let maxLength = 0;
  // Position index
  let position = -1;
  for (let i = 0; i < length; i++) {
    // Mirror of the current index
    let mirror = 2 * c - i;
    // Check if the mirror is outside the left boundary of current longest palindrome
    if (i < r) {
      p[i] = Math.min(r - i, p[mirror]);
    }
    // Indices of the characters to be compared
    let a = i + (1 + p[i]);
    let b = i - (1 + p[i]);
    // Expand the window
    while (a < length && b >= 0 && updatedString[a] === updatedString[b]) {
      p[i]++;
      a++;
      b--;
    }
    // If the expanded palindrome is expanding beyond the right boundary of
    // the current longest palindrome, then update c and r
    if (i + p[i] > r) {
      c = i;
      r = i + p[i];
    }
    if (maxLength < p[i]) {
      maxLength = p[i];
      position = i;
    }
  }
  let offset = p[position];
  let result = "";
  for (let i = position - offset + 1; i <= position + offset - 1; i++) {
    if (updatedString[i] !== "#") {
      result += updatedString[i];
    }
  }
  return result;
}

function getUpdatedString(s) {
  let sb = "";
  for (let i = 0; i < s.length; i++) {
    sb += "#" + s[i];
  }
  sb += "#";
  return sb;
}
```

6. [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/) - Medium

<https://redquark.org/leetcode/0006-zigzag-conversion/>

```js
function convert(s: string, numRows: number): string {
  if (s === null || numRows <= 0) {
    return "";
  }
  if (numRows === 1) {
    return s;
  }

  let result = "";
  const step = 2 * numRows - 2;
  for (let i = 0; i < numRows; i++) {
    for (let j = i; j < s.length; j += step) {
      result += s[j];
      if (i != 0 && i != numRows - 1 && j + step - 2 * i < s.length) {
        result += s[j + step - 2 * i];
      }
    }
  }
  return result;
}
```

7. [Reverse Integer](https://leetcode.com/problems/reverse-integer/) - Easy

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.

`notes: although Number(Array.from(num.toString()).reverse().join('')) works, that's lot of overhead`

```js
function reverse(x: number): number {
  let result = 0;
  let sign = x < 0 ? -1 : 1;

  x = Math.abs(x);
  while (x != 0) {
    result = result * 10 + (x % 10);
    x = Math.floor(x / 10);
  }

  //return result > 0x7fffffff ? 0 : result * sign;
  return result > Math.pow(2, 31) - 1 ? 0 : result * sign;
}
```

8. [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) - Medium

<https://redquark.org/leetcode/0008-string-to-integer-atoi/>

```js
function myAtoi(s: string): number {
  if (!s) {
    return 0;
  }
  // MAX and MIN values for integers
  const INT_MAX = 2147483647;
  const INT_MIN = -2147483648;

  s = s.trim();

  let i = 0;
  const isNegative = s[0] === "-";
  const isPositive = s[0] === "+";
  if (isNegative || isPositive) {
    i++;
  }

  let result = 0;
  while (i < s.length && s[i] >= "0" && s[i] <= "9") {
    result = result * 10 + Number(s[i]);
    i++;
  }

  result = isNegative ? -1 * result : result;
  if (result < INT_MIN) {
    return INT_MIN;
  }
  if (result > INT_MAX) {
    return INT_MAX;
  }
  return result;
}
```

9. [Palindrome Number](https://leetcode.com/problems/palindrome-number/) - Easy
   Given an integer x, return true if x is palindrome integer.

An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.

`notes: the point is how to utilize math to reserse a number`

```js
function isPalindrome(x: number): boolean {
  let reversedNumber = 0;
  let y = Math.abs(x);
  while (y != 0) {
    reversedNumber = reversedNumber * 10 + (y % 10);
    y = Math.floor(y / 10);
  }

  return reversedNumber > 0x7fffffff ? false : x === reversedNumber;
}
```

10. [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) - Hard

<https://redquark.org/leetcode/0010-regular-expression-matching/>

```js
function isMatch(s: string, p: string): boolean {
  const rows = s.length;
  const columns = p.length;

  if (rows == 0 && columns == 0) {
    return true;
  }
  if (columns == 0) {
    return false;
  }

  const dp = Array.from({ length: s.length + 1 }, () => [false]);

  dp[0][0] = true;

  for (let i = 1; i < columns + 1; i++) {
    if (p[i - 1] === "*") {
      dp[0][i] = dp[0][i - 2];
    } else {
      dp[0][i] = false;
    }
  }

  for (let i = 1; i < rows + 1; i++) {
    for (let j = 1; j < columns + 1; j++) {
      if (p[j - 1] === "*") {
        if (p[j - 2] === s[i - 1] || p[j - 2] === ".") {
          dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
        } else {
          dp[i][j] = dp[i][j - 2];
        }
      } else if (p[j - 1] === s[i - 1] || p[j - 1] === ".") {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = false;
      }
    }
  }
  return dp[rows][columns];
}
```

11. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) - Medium

<https://redquark.org/leetcode/0011-container-with-most-water/>

```js
function maxArea(height: number[]): number {
  let maximumArea = Number.MIN_SAFE_INTEGER;

  let left = 0;
  let right = height.length - 1;

  while (left < right) {
    let shorterLine = Math.min(height[left], height[right]);
    maximumArea = Math.max(maximumArea, shorterLine * (right - left));

    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return maximumArea;
}
```

12. [Integer to Roman](https://leetcode.com/problems/integer-to-roman/) - Medium

```js
function intToRoman(num: number): string {
  const M = ["", "M", "MM", "MMM"];
  const C = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
  const X = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
  const I = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
  return (
    M[Math.floor(num / 1000)] +
    C[Math.floor((num % 1000) / 100)] +
    X[Math.floor((num % 100) / 10)] +
    I[num % 10]
  );
}
```

13. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/) - Easy

<https://www.geeksforgeeks.org/converting-roman-numerals-decimal-lying-1-3999/>

```js
function romanToInt(s: string): number {
  let res = 0;
  for (let i = 0; i < s.length; i++) {
    let s1 = value(s.charAt(i));
    if (i + 1 < s.length) {
      let s2 = value(s.charAt(i + 1));

      if (s1 >= s2) {
        res = res + s1;
      } else {
        res = res + s2 - s1;
        i++;
      }
    } else {
      res = res + s1;
    }
  }

  return res;
}

function value(r): number {
  if (r == "I") return 1;
  if (r == "V") return 5;
  if (r == "X") return 10;
  if (r == "L") return 50;
  if (r == "C") return 100;
  if (r == "D") return 500;
  if (r == "M") return 1000;
  return -1;
}
```

14. [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)

```js
function longestCommonPrefix(strs: string[]): string {
  let longestCommonPrefix = "";

  if (strs == null || strs.length == 0) {
    return longestCommonPrefix;
  }

  let minimumLength = strs[0].length;
  for (let i = 1; i < strs.length; i++) {
    minimumLength = Math.min(minimumLength, strs[i].length);
  }

  for (let i = 0; i < minimumLength; i++) {
    let current = strs[0][i];
    for (let j = 0; j < strs.length; j++) {
      if (strs[j][i] != current) {
        return longestCommonPrefix;
      }
    }
    longestCommonPrefix += current;
  }
  return longestCommonPrefix;
}
```

15. [3Sum](https://leetcode.com/problems/3sum/)

<https://redquark.org/leetcode/0015-3-sum/>

```js
function threeSum(nums: number[]): number[][] {
  nums.sort((a, b) => a - b);
  const n = nums.length;
  const result = [];

  for (let i = 0; i < n; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }

    let j = i + 1;
    let k = n - 1;

    while (j < k) {
      if (nums[i] + nums[j] + nums[k] === 0) {
        result.push([nums[i], nums[j], nums[k]]);
        j++;

        while (j < k && nums[j] === nums[j - 1]) {
          j++;
        }
      } else if (nums[i] + nums[j] + nums[k] < 0) {
        j++;
      } else {
        k--;
      }
    }
  }
  return result;
}
```

16. [3Sum Closest](https://leetcode.com/problems/3sum-closest/)

<https://redquark.org/leetcode/0016-3-sum-closest/>

```js
function threeSumClosest(nums: number[], target: number): number {
  nums.sort((a, b) => a - b);
  const n = nums.length;
  let closest = nums[0] + nums[1] + nums[n - 1];

  for (let i = 0; i < n - 2; i++) {
    let j = i + 1;
    let k = n - 1;

    while (j < k) {
      let sum = nums[i] + nums[j] + nums[k];
      if (sum <= target) {
        j++;
      } else {
        k--;
      }
      if (Math.abs(closest - target) > Math.abs(sum - target)) {
        closest = sum;
      }
    }
  }
  return closest;
}
```

17. [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

```js
function letterCombinations(digits: string): string[] {
  let combinations = [];
  if (digits == null || digits.length == 0) {
    return combinations;
  }

  const lettersAndNumbersMappings = [
    "",
    "",
    "abc",
    "def",
    "ghi",
    "jkl",
    "mno",
    "pqrs",
    "tuv",
    "wxyz"
  ];
  findCombinations(combinations, digits, "", 0, lettersAndNumbersMappings);
  return combinations;
}

function findCombinations(
  combinations,
  digits,
  previous,
  index,
  lettersAndNumbersMappings
) {
  if (index == digits.length) {
    combinations.push(previous);
    return;
  }

  let letters = lettersAndNumbersMappings[Number(digits[index])];

  for (let i = 0; i < letters.length; i++) {
    findCombinations(
      combinations,
      digits,
      previous + letters[i],
      index + 1,
      lettersAndNumbersMappings
    );
  }
}
```

18. [4Sum](https://leetcode.com/problems/4sum/)

```js
function fourSum(nums: number[], target: number): number[][] {
  const quadruplets = [];

  if (nums == undefined || nums.length < 4) {
    return quadruplets;
  }

  nums.sort((a, b) => a - b);

  const n = nums.length;

  for (let i = 0; i < n - 3; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) {
      continue;
    }

    for (let j = i + 1; j < n - 2; j++) {
      if (j != i + 1 && nums[j] == nums[j - 1]) {
        continue;
      }

      let k = j + 1;
      let l = n - 1;

      while (k < l) {
        const currentSum = nums[i] + nums[j] + nums[k] + nums[l];
        if (currentSum < target) {
          k++;
        } else if (currentSum > target) {
          l--;
        } else {
          quadruplets.push([nums[i], nums[j], nums[k], nums[l]]);
          k++;
          l--;

          while (k < l && nums[k] == nums[k - 1]) {
            k++;
          }
          while (k < l && nums[l] == nums[l + 1]) {
            l--;
          }
        }
      }
    }
  }
  return quadruplets;
}
```

19. [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

```js
function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
  let slow = head;
  let fast = head;

  for (let i = 0; i < n; i++) {
    if (fast.next === null) {
      if (i === n - 1) {
        head = head.next;
      }
      return head;
    }
    fast = fast.next;
  }

  while (fast.next !== null) {
    slow = slow.next;
    fast = fast.next;
  }

  if (slow.next !== null) {
    slow.next = slow.next.next;
  }
  return head;
}
```

20. [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

```js
function isValid(s: string): boolean {
  const leftSymbols = [];

  for (let i = 0; i < s.length; i++) {
    if (s[i] === "(" || s[i] === "{" || s[i] === "[") {
      leftSymbols.push(s[i]);
    } else if (
      s[i] === ")" &&
      leftSymbols.length !== 0 &&
      leftSymbols[leftSymbols.length - 1] === "("
    ) {
      leftSymbols.pop();
    } else if (
      s[i] === "}" &&
      leftSymbols.length !== 0 &&
      leftSymbols[leftSymbols.length - 1] === "{"
    ) {
      leftSymbols.pop();
    } else if (
      s[i] === "]" &&
      leftSymbols.length !== 0 &&
      leftSymbols[leftSymbols.length - 1] === "["
    ) {
      leftSymbols.pop();
    } else {
      return false;
    }
  }
  return leftSymbols.length === 0;
}
```

21. [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

```js
function mergeTwoLists(
  l1: ListNode | null,
  l2: ListNode | null
): ListNode | null {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }

  let head = null;
  let temp = head;

  if (l1.val < l2.val) {
    head = new ListNode(l1.val);
    temp = head;
    l1 = l1.next;
  } else {
    head = new ListNode(l2.val);
    temp = head;
    l2 = l2.next;
  }

  while (l1 && l2) {
    if (l1.val < l2.val) {
      temp.next = new ListNode(l1.val);
      l1 = l1.next;
      temp = temp.next;
    } else {
      temp.next = new ListNode(l2.val);
      l2 = l2.next;
      temp = temp.next;
    }
  }

  while (l1) {
    temp.next = new ListNode(l1.val);
    l1 = l1.next;
    temp = temp.next;
  }

  while (l2) {
    temp.next = new ListNode(l2.val);
    l2 = l2.next;
    temp = temp.next;
  }
  return head;
}
```

22. [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)

```js
function generateParenthesis(n: number): string[] {
  const result = [];
  generate(result, "", 0, 0, n);
  return result;
}

function generate(result, s, open, close, n) {
  if (open === n && close === n) {
    result.push(s);
    return;
  }

  if (open < n) {
    generate(result, s + "(", open + 1, close, n);
  }

  if (close < open) {
    generate(result, s + ")", open, close + 1, n);
  }
}
```

23. [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

```js
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
  if (lists === undefined || lists.length === 0) {
    return null;
  }
  return mergeLists(lists, 0, lists.length - 1);
}

const mergeLists = (lists, start, end) => {
  if (start === end) {
    return lists[start];
  }
  let mid = start + Math.floor((end - start) / 2);
  let left = mergeLists(lists, start, mid);
  let right = mergeLists(lists, mid + 1, end);
  return merge(left, right);
};

const merge = (left, right) => {
  let head = new ListNode(-1);
  let temp = head;
  while (left !== null && right != null) {
    if (left.val < right.val) {
      temp.next = left;
      left = left.next;
    } else {
      temp.next = right;
      right = right.next;
    }
    temp = temp.next;
  }

  while (left != null) {
    temp.next = left;
    left = left.next;
    temp = temp.next;
  }

  while (right != null) {
    temp.next = right;
    right = right.next;
    temp = temp.next;
  }

  return head.next;
};
```
